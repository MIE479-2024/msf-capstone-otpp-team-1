import csv
from datetime import datetime
import numpy as np
from gurobipy import Model, GRB
import copy
import gurobipy as gp
import math

class Library:
    def __init__(self):
        self.raw_data = []
        self.raw_data_recent = []
        self.working_data = []
        self.sectors = set()
        self.data_length = 0
        self.benchmark = [] #dts, liquidity, returns, variance, duration
        self.constraint_priority = 0
        self.constraints = {'DTS':[], 'Duration':[], 'Weight':[], 'Liquidity':[], 'Cardinality':[]} #priority, level, name, lowerbound, upperbound
      

        # DTS
            # Portfolio
            # Sector

        # Duration
            # Portfolio
            # Sector

        # Weight
            # Security
            # Issuer
            # Sector

        # Liquidity
            # 1,2,3,4....

        # Cardinality
            # Portfolio
            # Sector


    def status(self):
        print('Working data currently contains ' + str(self.raw_data) + ' of ' + str(len(self.raw_data)) + ' total possible bonds.')

    def read_csv(self, file):
        self.clear_data()
        with open(file, newline='') as csvfile:
            datarows = [] #ISIN, name, year-maturity, coupon, sector, oas, liq_score, exp_return, std_dev, date, duration, bid_price, ask_price
            spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
            next(spamreader, None)
            for row in spamreader:
                
                line = ' '.join(row).split(',')
                
                line[2] = datetime.strptime(line[2], '%Y-%m-%d').date()
                line[9] = datetime.strptime(line[9], '%Y-%m-%d').date()
                datarows.append(line)
        self.raw_data = datarows
        self.sectors = set([a[4] for a in self.raw_data])
        self.create_working_data()

    def get_prev_portfolio_weights(self):
        # TBD, currently defined as equally weighted portfolio
        res = [a + [1/len(self.working_data)] for a in self.working_data ]
        return res

    def define_prev_portfolio_weights(self):
        self.prev_portfolio_weights = self.get_prev_portfolio_weights()


    def clear_data(self):
        self.working_data = []
        self.data_length = 0
        self.raw_data_recent = []
        self.sectors = set()
        self.data_length = 0
        self.benchmark = []
        self.constraint_priority = 0
        self.constraints = {'DTS':[], 'Duration':[], 'Weight':[], 'Liquidity':[], 'Cardinality':[]}

    def select_recent_data(self):
        max_date = max(a[9] for a in self.raw_data)
        self.raw_data_recent = [a for a in self.raw_data if a[9] == max_date]

    def define_maturity_bucket(self,data):
        year_dividers = [3, 8] # bucket ranges
        #for i in data:
            # TBD need to bin (can be pandas cut)
            
    def create_working_data(self):
        #issuer, sector, oas, liq_score, exp_return, variance, duration, bondname, date, maturity date, years-to-maturity, bid_price, ask_price
        self.working_data = [[a[1], a[4], float(a[5]), float(a[6]), float(a[7]), float(a[8]) ** 2, float(a[10]), a[0], a[9], a[2], (a[2]-a[9]).days / 365, float(a[11]), float(a[12])] for a in self.raw_data]
        
        # add t_cost 
        self.working_data = [a + [max(0,(a[12] - a[11])/(a[12] + a[11]))] for a in self.working_data]
        
        # get the previous portfolio weight
        self.working_data  = self.get_prev_portfolio_weights() # get the previous portfolio weights, now in index 14
        
        self.data_length = len(self.working_data)

    def filter_data_by_sector(self, category):
        self.working_data = [a for a in self.working_data if a[1] == category]
        self.data_length = len(self.working_data)

    def filter_data_by_liquidity(self, liquidity):
        self.working_data = [a for a in self.working_data if a[3] >= liquidity]
        self.data_length = len(self.working_data)

    def filter_data_by_negatives(self):
        self.working_data = [a for a in self.working_data if a[4] >= 0]
        self.data_length = len(self.working_data)


     
    def set_benchmark(self, dataset):
        total_return = 0
        total_liquidity = 0
        total_dts = 0
        total_duration = 0
        total_variance = 0

        returns = np.array([a[4] for a in dataset])
        variances = np.array([a[5] for a in dataset])
        weights = np.ones(len(dataset)) / len(dataset)

        total_return = np.sum(weights * returns)
        total_variance = np.sum(weights**2 * variances)

        for row in dataset:
            total_liquidity += row[3]
            total_dts += row[2] * row[6]
            total_duration += row[6]

        try:

            total_liquidity /= len(dataset)
            total_dts /= len(dataset)
            total_duration /= len(dataset)
        except:
            print('No dataset')

        return [total_dts, total_liquidity, total_return, total_variance, total_duration]

        self.benchmark = [total_dts, total_liquidity, total_return, total_variance, total_duration]


    def add_cash(self):
        with_cash = copy.deepcopy(self.working_data)
        # with_cash = [a for a in with_cash if a[4] >= 0]
        
        with_cash.append(['short_cash', '', 0, 10, 0, 0, 0,0,0,0,0,0,0,0,0])
        # with_cash.append(['long_cash', '', 0, 10, 0, 0, max([a[6] for a in self.working_data])])
        return with_cash

    def add_constraint(self, metric, level, name, lowerbound, upperbound):
        if metric not in ['DTS', 'Duration', 'Weight', 'Liquidity', 'Cardinality']:
            print('Error: Unknown Metric')
        elif metric in ['DTS', 'Duration', 'Cardinality']:
            if level not in ['Portfolio', 'Sector']:
                print('Error: Unknown Level')
            elif name not in {'Portfolio'} | self.sectors:
                print('Error: Unknown Sector')
            else:
                self.constraints[metric].append([self.constraint_priority, level, name, lowerbound, upperbound])
                self.constraint_priority += 1

        elif metric == 'Weight':
            if level not in ['Security', 'Issuer', 'Sector']:
                print('Error: Unknown Level')
            else:
                self.constraints[metric].append([self.constraint_priority, level, name, lowerbound, upperbound])
                self.constraint_priority += 1

        elif metric == 'Liquidity':
            if level not in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
                print('Error: Unknown Level')
            else:
                self.constraints[metric].append([self.constraint_priority, level, name, lowerbound, upperbound])
                self.constraint_priority += 1

    def optimize(self):
        
        
        self.benchmark = self.set_benchmark(self.working_data)

        dataset = self.add_cash()

        model = Model("Optimal")

        weights = []
        binary = []
        turnover_change=[]
        transaction_dummy=[]

        for i in range(len(dataset)):
            weight_var = model.addVar(name=f"{i}~~{dataset[i][0]}", lb=0.0, ub=1.0)
            weights.append(weight_var)
            cardinal_var = model.addVar(name=f"{i}|{dataset[i][0]}", vtype=GRB.BINARY)
            binary.append(cardinal_var)


            #Binary Inequality
            model.addConstr(weight_var <= cardinal_var)
            model.addConstr(weight_var * 10**9 >= cardinal_var)


        # T cost

        transaction_dummy = model.addVars(len(dataset),name=[a[0] for a in dataset][i], lb=0.0, ub=1.0)
        turnover_change = model.addVars(len(dataset),name=[a[0] for a in dataset][i], lb=0.0, ub=1.0)

        
        model.addConstrs((weights[i] - ([a[14] for a in dataset][i])  == turnover_change[i]  for i in range(len(weights))), "turnover")
        
        for i in range(len(dataset)):
            model.addGenConstrAbs(transaction_dummy[i],turnover_change[i])

        #Set Objective
        model.setObjective(sum((weights[i] * [a[4] for a in dataset][i]  - transaction_dummy[i] * [a[13] for a in dataset][i] ) for i in range(len(dataset))),
            GRB.MAXIMIZE
        )
        #model.getObjective()
        #Full Investment
        model.addConstr(sum(weights[i] for i in range(len(dataset))) == 1.0, "full_investment")
        print(self.constraints)
        for metric, constraints in self.constraints.items():
            if len(constraints) == 0:
                continue # if no constraints defined, skip
            if metric == 'DTS':
                for constraint in constraints:
                    if constraint[1] == 'Portfolio':
                        model.addConstr(
                            sum(weights[i] * [a[2]*a[6] for a in dataset][i] for i in range(len(dataset))) <= self.benchmark[0] + constraint[-1], f"Constraint_{constraint[0]}"
                        )
                    else:
                        sector_benchmark = benchmark = self.set_benchmark([a for a in dataset if a[1] == constraint[2]])
                        sector_weight = sum(weights[i] for i in range(len(dataset)) if dataset[i][1] == constraint[2])
                        if sector_weight > 0:
                            model.addConstr(
                            sum(weights[i] * [a[2]*a[6] for a in dataset][i] for i in range(len(dataset)) if dataset[i][1] == constraint[2]) / sector_weight <= sector_benchmark[0] + constraint[-1], f"Constraint_{constraint[0]}"
                        )

            elif metric == 'Duration':
                for constraint in constraints:
                    if constraint[1] == 'Portfolio':
                        model.addConstr(
                            sum(weights[i] * dataset[i][6] for i in range(len(dataset))) <= self.benchmark[4] + constraint[-1], f"Constraint_max_{constraint[0]}"
                        )
                        model.addConstr(
                            sum(weights[i] * dataset[i][6] for i in range(len(dataset))) >= self.benchmark[4] - constraint[-1], f"Constraint_min_{constraint[0]}"
                        )

                    else:
                        sector_benchmark = benchmark = self.set_benchmark([a for a in dataset if a[1] == constraint[2]])
                        sector_weight = sum(weights[i] for i in range(len(dataset)) if dataset[i][1] == constraint[2])
                        if sector_weight > 0:
                            model.addConstr(
                                sum(weights[i] * dataset[i][6] for i in range(len(dataset)) if dataset[i][1] == constraint[2]) / sector_weight <= sector_benchmark[4] + constraint[-1], f"Constraint_max_{constraint[0]}"
                            )
                            model.addConstr(
                                sum(weights[i] * dataset[i][6] for i in range(len(dataset)) if dataset[i][1] == constraint[2]) / sector_weight >= sector_benchmark[4] - constraint[-1], f"Constraint_min_{constraint[0]}"
                            )

            elif metric == 'Weight':
                for constraint in constraints:
                    if constraint[1] == 'Security':
                        model.addConstr(
                            sum(weights[i] for i in range(len(dataset)) if dataset[i][7] == constraint[2]) <=constraint[-1], f"Constraint_{constraint[0]}"
                        )
                    elif constraint[1] == 'Issuer':
                        model.addConstr(
                            sum(weights[i] for i in range(len(dataset)) if dataset[i][0] == constraint[2]) <=constraint[-1], f"Constraint_{constraint[0]}"
                        )

                    elif constraint[1] == 'Sector':
                        model.addConstr(
                            sum(weights[i] for i in range(len(dataset)) if dataset[i][1] == constraint[2]) <=constraint[-1], f"Constraint_{constraint[0]}"
                        )

            elif metric == 'Liquidity':
                for constraint in constraints:
                    model.addConstr(
                        sum(weights[i] for i in range(len(dataset)) if dataset[i][3] <= constraint[2]) <= constraint[-1], f"Constraint_{constraint[0]}"
                        )

            elif metric == 'Cardinality':
                if constraints[1] == 'Portfolio':
                    model.addConstr(
                        sum(binary[i] for i in range(len(dataset))) <= constraint[-1], f"Constraint_{constraint[0]}"
                        )

                elif constraints[1] == 'Sector':
                    model.addConstr(
                        sum(binary[i] for i in range(len(dataset)) if dataset[i] == constraint[2]) <= constraint[-1], f"Constraint_{constraint[0]}"
                        )
        # view constraints
        model_constraints = model.getConstrs()
        for m in model_constraints:
            print(m)

        if model.status == GRB.OPTIMAL:
            print("Optimal solution found.")
            for v in model.getVars():
                print(f"{v.VarName} = {v.X}")
        else:
            print("Model is infeasible. Checking constraints...")
            model.computeIIS()
            model.write("model.ilp")

